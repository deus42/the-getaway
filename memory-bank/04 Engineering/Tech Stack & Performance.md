---
category: engineering
type: tech
---

# Tech Stack & Performance

<game_system id="technology_development" status="partial">
Technology & Development Focus

<development_approach name="single_player">
Single-Player Focus

The Getaway is designed as a deep single-player experience with no multiplayer or online components in the initial scope. This focus has several implications:
	•	Narrative and Systems Oriented for Solo Play: All story elements are tailored to a single protagonist making decisions. There’s no need to accommodate multiple players’ choices or dialogue in conversations. The branching narrative can fully revolve around the player’s actions without syncing states with others.
	•	No Networking Required: The development does not need to implement client-server architecture or peer-to-peer connections. This simplifies testing and debugging significantly, as we avoid issues like lag, desync, or server load. It also removes concerns about cheating or moderation that come with multiplayer.
	•	Turn-Based Suited for Single-Player: Turn-based combat is naturally slower-paced and could be problematic to synchronize in multiplayer. By being single-player, we ensure the player can take their time on each turn, even walk away mid-combat if needed, since no one else is waiting. We can also allow liberal use of pause, save, or even rewinds (if we wanted a feature to undo a turn for accessibility) without concern.
	•	Resource Allocation: All development resources (programming, design, content creation) go into fleshing out the world and mechanics rather than building matchmaking, multiplayer level design, or balancing PvP. This means a richer world and AI since those are our “opponents” and allies rather than other players.
	•	Possible Future Multiplayer: We keep in mind that if the game is successful, a co-op or small-scale multiplayer mode could be a future addition (for example, two players exploring the city together). However, that would require reworking turn-based combat to allow simultaneous turns or an asynchronous system, plus ensuring the world simulation works with multiple inputs. For now, these complexities are set aside to deliver the best single-player game we can.
	•	Player Community & Modding: Single-player games often thrive on modding and community-driven content post-release. While not a core focus now, using a browser platform means modding might be as simple as editing some data files or writing JavaScript plugins, which we can consider documenting if there’s interest. But there’s no official user-generated content system at launch.
	•	Save System: Single-player focus allows robust save/load functionality. The player can have multiple save files, manual saves, quicksaves, etc., which in a multiplayer context would be restricted. We should implement an easy save system (maybe even an auto-save at key points) so players can experiment with different choices and have fallback points. This supports the branching narrative aspect, letting curious players explore alternate outcomes by reloading if they desire.

In summary, committing to single-player lets us maximize depth and immersion without multiplayer compromises. The player will feel like the sole central force in the city's story, which aligns perfectly with the narrative design.
</development_approach>

<technical_stack name="browser_platform">
<implementation_status>⚠️ PARTIAL</implementation_status>
Platform & Engine (Browser-Based Deployment)

The game will be delivered via web browsers, leveraging modern web technology to reach players instantly without installation. Here's our plan for the tech stack and engine considerations:
	•	Language: We will develop primarily in TypeScript, which compiles to JavaScript. TypeScript offers static typing, which will help catch errors early and make the code more maintainable as it grows. This is especially useful with AI-assisted generation, as the types can guide the AI to use functions and data structures correctly. Since TypeScript is a superset of JavaScript, we can seamlessly integrate any libraries or frameworks needed.
	•	Rendering Technology: The game will use HTML5 Canvas/WebGL for rendering. Given the likely 2D isometric perspective, a 2D engine with WebGL acceleration is ideal for performance. We are considering using an established game framework like:
	•	Phaser 3: A popular 2D game framework that supports tilemaps, sprites, animations, input handling, and has an easy learning curve. It would let us get a head start on map rendering and physics (though a turn-based game won’t need heavy physics).
	•	Pixi.js: A rendering library that is very efficient at drawing a large number of sprites. It doesn’t have as many built-in game mechanics as Phaser (like no integrated physics or camera logic out-of-the-box), but it’s great for custom engine development if we want full control.
	•	Babylon.js or Three.js: These are more 3D engines but can do 2D/orthographic. Overkill if we stick to 2D, but if we wanted to incorporate any 3D elements or effects, they are options. Probably not necessary here.
	•	Engine Choice: Leaning towards Phaser 3 for its all-in-one features. It has WebGL support with canvas fallback, and good community support. We can use its tilemap system for the grid-based levels and combat maps, which will save us time (we can design levels in Tiled map editor and load them easily). Phaser also handles audio, animated sprites, and scene management which covers a lot of basics.
	•	Custom Systems on Top: Regardless of engine, we will be building custom systems for:
	•	Turn-based combat logic (turn scheduler, AP system, pathfinding on grid).
	•	World simulation (NPC AI behaviors, day-night cycle).
	•	Dialogue and quest management (likely not provided by any engine, so we code this).
	•	UI elements like inventory screens, character sheets, etc. (Phaser can be used for basic UI or we might overlay HTML for complex UI like inventory grids to leverage CSS styling).
	•	Browser Compatibility: Target modern browsers: Chrome, Firefox, Edge, Safari (latest versions). We’ll test on each. We plan to use features like WebGL2 and possibly Web Workers (for offloading AI calculations) which are well-supported now. We also consider memory limits: browsers can usually handle hundreds of MBs of data, but we must be mindful on low-end machines. We may provide graphics settings (like disabling certain effects) if performance varies widely.
	•	Deployment Model: The game will be hosted on a web server, and players can play by visiting the URL. We might package it as a Progressive Web App (PWA) so it can be “installed” and run offline after initial load. Saves could be stored in browser local storage or a cloud sync if we implement that. Using web also eases updates – we can patch the game and all players get the new version on next load, though we’ll need to ensure save data compatibility.
	•	Asset Loading: We will use engine support or custom loading routines to load images (sprite sheets, tilesets), audio files, and data (JSON for quests, dialogues, item definitions). These will be likely stored in a compressed format on the server and uncompressed in memory. Given it’s a browser, we’ll implement a loading screen and possibly stream in assets in the background to reduce initial load time. We should aim to keep initial download small (maybe under 10 MB) so players get into the game quickly, then load additional content (like different district graphics or music) as needed.
	•	Resolution and Graphics: We should support different screen sizes since browser windows vary. Likely we design for a 16:9 aspect ratio at 1280x720 or 1920x1080 and ensure UI scales or anchors to be usable at other aspect ratios (like 4:3 or ultrawide, or on a tablet). Using CSS or engine scaling, we can handle resizing. Art direction preference is painterly-noir 2.5D/isometric (not pixel art, not full 3D); assets should remain readable under dynamic lighting and postFX while staying feasible for a solo-dev pipeline.
	•	Audio: We will use the Web Audio API (accessible via frameworks or vanilla) for sounds and music. We plan formats for broad support (ogg for Firefox, mp3 for others, or use engine to handle multiple). We’ll need a sound manager to play effects (like gunshots, engine noises, ambient city sounds) and music tracks that can change per zone or situation (calm exploration music vs combat music). This is part of polish, but noting it now in tech design.
	•	External Libraries: Besides the main engine, we might use libraries for:
	•	Pathfinding (e.g., implement A* ourselves or use something like easystar.js for tilemaps).
	•	AI behavior trees or planners for NPC decisions, unless we code our own simple state machines.
	•	Physics if any (unlikely since mostly grid-based movement).
	•	UI frameworks (could embed an HTML UI overlay using React/Vue for complex menus if desired, though that adds complexity).
	•	Save data serialization (we can likely just use JSON and localStorage/IndexedDB APIs).
	•	WebAssembly (WASM) Option: If performance becomes an issue in pure JS for certain parts (like a very heavy combat simulation or pathfinding with hundreds of NPCs), we have the option to write that part in a lower-level language (C++ or Rust) and compile to WASM for integration. For now, we anticipate being fine in JS/TS, but it’s good to know we can optimize later with WASM if needed (for example, a complex AI routine that can be offloaded).
	•	Testing in Browsers: We’ll set up a local dev environment (using something like webpack or parcel to bundle our TS code and serve it) to test the game in a browser as we build. We’ll use debug tools (like showing collision grids, AI state debug overlays) that we can toggle during development. Browser dev tools will be crucial for profiling memory and CPU usage.

By using a browser-based stack, we tap into a wide accessibility (anyone with a browser can play, across OS platforms, possibly even tablets). We just have to carefully manage performance and asset size to fit the constraints of web games. The chosen technology (TypeScript + Phaser or similar) is conducive to iterative development and AI-assisted coding, because many patterns and boilerplate can be generated or filled in by AI given clear descriptions (like classes for inventory items, functions for turn calculations, etc., all of which are fairly standard to code once outlined in design).
</technical_stack>

<technical_approach name="performance">
Performance Considerations

Running an open-world, turn-based simulation in a browser means we must optimize for performance from the start:
	•	World Streaming & Level of Detail: We will stream the world in chunks. The city can be divided into sectors (perhaps by district). Only the current sector and immediately adjacent ones are fully active with NPC AI and detail. Farther areas are either unloaded or running in a low-detail simulation. For example, if the player is in the Slums sector, we load the NPCs and events there. The Downtown and Industrial sectors next door update in a lightweight way (maybe just faction presence changes or major events) and more distant ones freeze or update hourly rather than per frame. As the player moves, we load new sectors ahead of time (when the player nears a boundary, begin loading the next sector’s data). This prevents memory overload and keeps processing focused.
	•	Background Simulation Throttling: For NPC actions that are not in the player’s vicinity, we don’t need per-second accuracy. We can simulate at a much slower rate or abstractly. For instance, rather than simulating every patrol route off-screen, we could determine that “per hour, faction A and B have X chance to clash in district Y” and only if the player goes there do we resolve the details. Web Workers could be used for some of this background calculation, utilizing multi-core without freezing the main game. A web worker could handle things like advancing the world state each in-game hour (processing needs, spawns, etc.), then the main thread picks that up.
	•	Pathfinding Optimization: Pathfinding (like NPCs moving on the grid or navigating city streets) can be CPU-heavy if many NPCs do it simultaneously. We’ll leverage algorithms like A* with heuristics tuned for grid movement. We can precompute navigation meshes or grids for static parts of the world. Perhaps each sector has a navgraph for major routes. In combat, the area is limited, so pathfinding is manageable (even there, if multiple NPCs need paths, we can stagger their calculations across frames or use a single path search that many NPCs can use if they’re following similar routes). Using Web Workers for pathfinding is an option if we find the main thread bogged down when lots of movement happens.
	•	AI Efficiency: NPC AI in the open world uses simple state machines (patrol, chase, flee, etc.) with infrequent decision ticks. Combat AI is more complex (needs to evaluate cover, targets, etc.), but combat usually involves a limited number of actors at once (say up to 10v10 units). We can afford more CPU per AI in combat since it’s turn-based (player will not notice a half-second think time for AI if it means smarter moves, though we aim for much less). In contrast, dozens of AI wandering the city in real-time need to be very lightweight. We’ll budget how many active NPCs can be around the player – perhaps in a busy market there are 20 NPCs with routines, which is fine for modern JS engines. For larger crowds, we might use tricks like grouping them or simulating only a few and duplicating behavior (crowd simulation techniques).
	•	Graphics and Rendering: We need to maintain 60 FPS for smoothness (or at least a stable 30 if on low-end). Using WebGL means we can render many sprites efficiently, but we should:
	•	Use sprite atlases to minimize draw calls (combine many small textures into one so the GPU can draw them in one go).
	•	Limit layer overlap. In isometric view, layering is needed for depth sorting (drawing things in the correct order). We might implement our own simple painter’s algorithm for sorting sprites by their y-coordinate each frame (commonly done in 2D). This is fine up to a point – if there are hundreds of entities, sorting becomes a bit heavy but still okay in JS if optimized.
	•	Use particle effects sparingly. Explosions, smoke, etc. should be capped. We might pre-render some effects as sprite animations instead of real-time particle simulations.
	•	Provide options to disable or reduce effects, or lower texture resolution, for slower devices.
	•	Memory Management: JavaScript has garbage collection which can cause hitches if a lot of garbage accumulates. We’ll aim to reuse objects and arrays where possible. For instance, instead of deleting an entity object when an NPC dies, maybe pool it for reuse for the next NPC that spawns. Large data structures like the world grid can be created once and updated rather than recreated. Also, be mindful of not leaking memory - remove event listeners, references when sectors unload so GC can clean them. We’ll test via browser dev tools for leaks (watching memory usage as you travel back and forth between areas).
	•	Audio Performance: We’ll pre-load audio and stream longer music to avoid big memory usage. Web audio can handle many sounds, but we should throttle how many play at once (don’t have 10 gunshot sounds overlapping excessively; maybe limit polyphony or use a pooling system for sound channels).
	•	Saving/Loading: Saving the entire world state can be intensive if we try to do it all at once. But since it’s single-player, it’s fine to pause the game during save. We might compress the save data (maybe using JSON stringify and compress algorithm, or an IndexedDB structure). Saves not too large (maybe a few MB at most) so that should be okay. We’ll autosave at key points but not too frequently (maybe once every in-game hour or after big events) to avoid stutter.
	•	Profiling and Testing: During development, we will profile the game on different hardware: a high-end PC, a mid-range laptop, maybe a tablet. We’ll identify bottlenecks (e.g., if pathfinding is slow with current approach, or if rendering certain tiles is expensive). Optimizations will follow: sometimes in algorithm (reducing complexity), sometimes in toggling engine features (maybe turning off expensive physics if we accidentally enabled it for something trivial), or in content (if a certain effect or asset is too heavy).
	•	Fallbacks: If some browsers or devices struggle, we have fallback plans:
	•	Allow a “low detail mode” that reduces draw distance (if applicable in city view), lowers NPC counts, disables shadows, etc.
	•	If WebGL isn’t available (rare these days), allow Canvas rendering with simplified visuals (no shaders, etc.).
	•	Ensure the game can still run at 30 FPS without logic breaking (tie logic updates to real time, not frames, for consistency).
	•	Continuous Optimization: As we add features, we will regularly test performance to catch issues early. For example, when adding dynamic NPC schedules, test with dozens of NPCs active. When adding deferred large systems (e.g., vehicles Post-MVP), test fast traversal across sectors to see if loading keeps up.

In summary, our strategy is to optimize smartly: update what needs updating, render what needs rendering, and no more. By controlling scope (single-player, 2D view) and using the power of WebGL and multi-threading (web workers), we anticipate being able to create a rich open world that runs smoothly in a browser environment.
</technical_approach>

<technical_approach name="development_tools">
Technical Stack & Tools

To manage development efficiently and integrate AI-assisted coding, we outline our tools and practices:
	•	Version Control with Git: We will use Git for source code management. The repository will contain code, configuration files, and possibly even content like dialogue JSON (though large binary assets like images might be handled through a separate pipeline or Git LFS). Git allows multiple team members (and AI suggestions) to contribute with trackable changes. We’ll commit frequently with clear messages, which also serves as documentation of progress. If an AI tool suggests changes, those will go through review (we won’t auto-commit AI code without testing).
	•	Development Environment: We will set up a comfortable IDE (like Visual Studio Code) with TypeScript support. VSCode integrates well with Git and has extensions for TypeScript/Phaser development. It also can integrate AI coding assistants like GitHub Copilot. We’ll configure linting and formatting (ESLint, Prettier) to keep code style consistent, which also helps AI outputs be consistent.
	•	AI-Assisted Workflow: Using tools like Copilot or GPT-based code generation, we can do things like:
	•	Generate boilerplate classes (e.g., an Item class with properties for name, weight, value, etc., and maybe some default methods).
	•	Get suggestions for algorithms (like “function to calculate line-of-sight on grid” – the AI can draft it, and we refine and verify).
	•	Quickly produce repetitive content structures (maybe writing JSON schema for items or copying patterns for multiple skills).
	•	However, we’ll remain cautious: AI can introduce subtle bugs or inefficiencies, so all AI-generated code is reviewed and tested.
	•	Modular Architecture: We’ll structure the code into modules: e.g., WorldSimulation, CombatSystem, DialogSystem, QuestManager, InventorySystem, etc. Each module has defined interfaces. This encapsulation helps assign tasks (perhaps AI works on one module at a time via prompts like “Implement function X in module Y according to spec”). It also makes debugging easier since subsystems are somewhat independent.
	•	Data-Driven Design: Wherever possible, use data files (JSON or TS objects) for content: item definitions, enemy stats, dialogue lines, quest scripts. This means less hard-coding and easier tweaking. AI can even assist in generating large data sets – for instance, if we need a hundred item descriptions or a variety of NPC names, an AI can help generate those following a pattern. Data-driven also aids modding and future expansions.
	•	Testing & QA: We will write unit tests for critical systems using a JS testing framework (like Jest or Mocha). For example, test that the combat damage calculation works as expected, or that saving and loading restores the same world state. AI could help write some tests by explaining the scenario (“Write a test for the Inventory system ensuring adding an item increases weight and removing decreases it accordingly”). Continuous Integration (CI) can run these tests on each commit to catch regressions. In a browser context, we might also do automated playtests using headless browser scripts (or simply rely on human QA for playthroughs).
	•	Logging and Debugging: During development, we’ll have debug logs (which can be toggled off for release) to trace AI behavior decisions, quest state changes, etc. If something goes wrong in the simulation, these logs will be invaluable. We can also build a debug menu in-game (accessible with a key) to toggle states (make it noon, spawn a certain NPC, win a combat, etc.) to test various scenarios quickly.
	•	Asset Pipeline: Use tools for asset optimization:
	•	Texture Packer to combine sprites into atlases.
	•	Audacity or similar to compress audio.
	•	Possibly procedural generation tools for some graphics (or AI image generation for portraits concept that then get touched up by artists, though that’s a content pipeline consideration).
	•	We’ll script the build process (maybe npm scripts or a tool like Gulp/Webpack) to take raw assets and produce web-optimized versions and manifest files. This process can be automated in CI as well.
	•	Documentation: Maintain documentation of code architecture and data formats (could be markdown files in repo). AI tools can help generate documentation by summarizing code or ensuring our doc strings are comprehensive. This design document itself can evolve into a living document or spawn more technical design docs for each subsystem.
	•	Performance Monitoring: We might include a debug overlay that shows FPS, number of active entities, memory usage, etc., to spot performance issues during test sessions. If using an engine like Phaser, some of this can be gleaned from its internal stats or Chrome’s performance profiles.
	•	Security: Being a browser game, code is essentially open to users. We won’t have sensitive secrets in the code (any critical logic is client-side anyway due to single-player). But we should ensure no obvious exploits like giving players an easy way to execute arbitrary JS through console (though since it’s not competitive, cheating is only self-spoiling). If we do any cloud sync or online features, we’ll secure those endpoints appropriately.
	•	Deployment & Updates: For hosting, a simple static file server or itch.io upload might suffice. We just need to ensure versioning doesn’t break saves. We could embed a version number in save data and write upgrade logic if needed (e.g., if we add a new stat in a patch, handle older saves missing it). AI can assist by analyzing differences between versions and suggesting migration code.

By planning our development tooling and workflow, we set ourselves up to efficiently build the game and maintain high code quality. The use of AI is a force-multiplier but not a replacement for thoughtful design and testing. This design document itself will guide the AI in generating code aligned with the intended features, essentially translating the high-level descriptions into actual game mechanics.
</technical_approach>

<technical_approach name="future_proofing">
Future-Proofing & Scalability

We aim to write code and design systems that are robust and extensible, so the project can grow or be adapted beyond the initial release:
	•	Modular & Extensible Code: As mentioned, an entity-component-system (ECS) architecture or similarly modular approach ensures new content or entity types can be added without rewriting core logic. For example, if we later introduce flying drones as a new entity, we can just add a “flying” component or an AI behavior for flying, without overhauling the combat system. The quest system is data-driven so new quests (even community-made) could be plugged in if they follow the data format. Item definitions can be added to JSON without touching the code, unless a new effect requires a new code handler (which we could plan for via an effect scripting system or generic effect handler in combat).
	•	Scalability of World Size: If we decide to expand the city or add a new region in an update or sequel, the streaming system and sector-based approach will handle it as long as memory allows. We should avoid hard-coding limits like “only 10 sectors” or “max 100 NPCs” – use dynamic structures (maps, lists) that can grow. Memory is a constraint, but as devices improve, the same code could handle more content.
	•	Engine Flexibility: If down the line we wanted to port the game to a native platform (like release on Steam as a desktop app), we could wrap it with Electron or use something like NW.js. The web code would run with minor adjustments (file system for saves perhaps). Similarly, porting to mobile could be done via Cordova or just relying on mobile browsers if the UI is made responsive to touch. Therefore, we won’t design anything that fundamentally requires keyboard-only or assumes a very large screen – keeping UI somewhat flexible will help potential mobile or tablet play.
	•	Multiplayer Considerations: While not in scope now, some design choices can ease future multiplayer. For instance, if we keep game logic separated from rendering, we could one day run the logic on a server or sync states. Turn-based combat could theoretically be adapted to hot-seat or asynchronous multiplayer if each turn’s actions can be serialized and sent. We won’t implement this now, but by not entangling input handling with game state too tightly, we leave a door open.
	•	Continuous Improvement via AI: As AI tools improve, we can use them not just in initial development but for patches and expansions. Having a clear design (this doc) and clean codebase means when we describe a new feature to an AI assistant, it can provide help consistent with existing code. We’ll maintain updated documentation reflecting any changes (for example, if we tweak the combat formula during balancing, update the design doc or a balancing doc accordingly). This synergy ensures our design and implementation stay aligned, which is crucial for long-term maintenance.
	•	Community Feedback Loop: Post-release, we expect feedback on balance or feature requests. Our architecture should allow tweaking numbers easily (e.g., change an enemy’s HP in a data file rather than code). If players want a new feature (say, a new faction or a new vehicle type), we check if our current systems support it or need extension. Because we’ve tried to generalize systems (like faction reputation is already dynamic, adding a new faction is mostly adding data and a few references in world generation), we can respond to feedback without massive refactors.
	•	Performance Headroom: We will optimize for current typical hardware, but also ensure the game can run on weaker machines by providing options. If technology leaps (browsers get much faster, or WebAssembly becomes more accessible), we could update the game to push view distance further or increase NPC counts for those who can handle it. The design should have configurable constants for such things (max active NPCs, etc.), making it easier to scale up or down.
	•	Codebase Management: We might eventually open source parts of the project (or at least share code with modders). Clean separation of proprietary assets (art, story) from code will be considered for that scenario. In any case, our internal code needs to be understandable by new team members or our future selves, which means writing clear code, with comments and docs. AI can help document code, but we must also manually ensure key algorithms are explained.
	•	Testing for Edge Cases: As content grows, edge cases multiply (e.g., what if the player becomes hated by all factions before a certain main quest? Does the game still have a path forward?). We should use a combination of automated tests and scenario testing to cover unusual but possible states. This also ties into save system – ensure saves from any point can be loaded and the game can progress to an ending without getting stuck, even if some content was skipped or some NPCs died. Designing quests with multiple fail-safes or fallbacks (like if an NPC is dead, allow quest completion via a note or alternate NPC) is part of this robustness.

By focusing on future-proofing, we hope The Getaway can be a platform for storytelling and gameplay that lasts beyond the initial content. Whether through official expansions or community mods or just the flexibility to patch and improve, the game's design and code should accommodate growth and change without breaking down. In essence, we treat this not just as a one-off game but as a living project that can evolve.
</technical_approach>
</game_system>
